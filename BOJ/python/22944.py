# 문제
# 가로, 세로 길이가 $N$인 정사각형 격자가 있다. 해당 격자에는 두 곳을 제외한 모든 곳에 체력을 1씩 감소시키는 죽음의 비가 내리고 있다. 죽음의 비가 안내리는 곳은 현재 있는 위치와 안전지대라는 곳이다. 현재 있는 위치에도 곧 비가 내릴 예정이라 빨리 이 죽음의 비를 뚫고 안전지대로 이동해야한다.
#
# 다행히도 격자에는 죽음의 비를 잠시 막아주는 우산이 $K$개 존재한다. 우산에는 내구도 $D$라는 개념이 존재한다. 우산에 비를 맞으면 내구도가 1씩 감소하고, 내구도가 0이 되는 순간 우산은 사라진다. 문제에서 주어지는 우산의 내구도는 모두 $D$로 동일하다.
#
# 격자에서 이동을 할 때 다음과 같이 순서로 진행된다.
#
# 상하좌우로 이동한다. 만약 이동할 곳이 격자 밖이라면 이동할 수 없다.
# 이동한 곳이 안전지대라면 반복을 종료한다.
# 이동한 곳에 우산이 있다면 우산을 든다. 만약, 이동할 때부터 우산을 가지고 있다면 가지고 있는 우산을 버리고 새로운 우산으로 바꾼다.
# 버린 우산은 더 이상 사용할 수 없다.
# 죽음의 비를 맞았을 때, 우산을 가지고 있다면 우산의 내구도가 1이 감소하고 만약 우산을 가지고 있지 않는다면 체력이 1 감소한다.
# 만약 우산의 내구도가 0이 되면 들고 있는 우산이 사라진다.
# 만약 체력이 0이 되면 죽는다...
# 아직 체력이 남았다면 안전지대까지 위 과정을 반복한다.
# 현재 있는 위치에서 안전지대로 얼마나 빠르게 이동할 수 있는지 구해주자.
#
# 입력
# 첫 번째 줄에 정사각형 격자의 한변의 길이인 $N$와 현재 체력 $H$, 우산의 내구도 $D$가 공백으로 구분되어 주어진다.
#
# 다음 $N$개의 줄에는 정사각형 격자의 정보가 $N$개의 문자로 붙어서 주어진다. 이때 주어지는 문자는 우산은 "U", 현재 있는 위치 "S", 안전지대 "E", 빈 칸 "."만 존재한다. 현재 있는 위치 "S"와 안전지대 "E"는 반드시 1개 존재한다.
#
# 출력
# 안전지대로 이동할 때 최소 이동 횟수를 출력한다. 만약 안전지대로 이동하지 못하는 경우에는 -1을 출력한다.
#
# 제한
#  $4 ≤ N ≤ 500$ 
#  $0 ≤ K ≤ 10$ 
#  $1 ≤ H ≤ 10,000$ 
#  $1 ≤ D ≤ 5,000$ 
# 주어지는 모든 수는 정수이다.
from collections import deque
n, h, d = map(int, input().split())
grid = [list(str(input())) for _ in range(n)]
sy, sx = 0, 0
for i in range(n):
    for j in range(n):
        if grid[i][j] == 'S':
            sy, sx = i, j
dy, dx = [0, 1, 0, -1], [1, 0, -1, 0]
visited = [[0 for _ in range(n)] for _ in range(n)]
def to_safety_zone():
    q = deque()
    q.append((sy, sx, h, 0, 0))
    visited[sy][sx] = h
    while q:
        y, x, cur_h, cur_d, cnt = q.popleft()
        for i in range(4):
            ny, nx = y + dy[i], x + dx[i]
            if 0 <= ny < n and 0 <= nx < n:
                if grid[ny][nx] == 'E':
                    return cnt+1
                nxt_h, nxt_d = cur_h, cur_d
                if grid[ny][nx] == 'U':
                    nxt_d = d
                if nxt_d:
                    nxt_d -= 1
                else:
                    nxt_h -= 1
                if not nxt_h:
                    continue
                if visited[ny][nx] < nxt_h:
                    visited[ny][nx] = nxt_h
                    q.append((ny, nx, nxt_h, nxt_d, cnt+1))
    return -1
print(to_safety_zone())
