# 생명과학부 랩 인턴
# 실력체크
# 정답률 32% · 제출 182회 · 예상 소요 시간 180분 이상

# 추천해요
# 아쉬워요
# ko-kr
# 생명과학부 랩 인턴을 시작하게 된 승용이는 n * m 격자판에서 움직이는 곰팡이를 채취하는 일을 맡았습니다. 격자판에서 곰팡이를 채취할 때는 다음과 같은 규칙을 이용합니다. 아래 그림에서 빨간색으로 표시된 숫자는 곰팡이의 크기를 의미하고, 파란색으로 표시된 숫자는 속력을 의미합니다.



# 승용이는 첫번째 열부터 탐색을 시작합니다.

# 해당 열의 위에서 아래로 내려가며 탐색할 때 제일 빨리 발견한 곰팡이를 채취합니다. 곰팡이를 채취하고 나면 해당 칸은 빈칸이 됩니다.

# 해당 열에서 채취가 끝나고 나면 곰팡이는 이동을 시작합니다.

# 입력으로 주어진 방향과 속력으로 이동하며 격자판의 벽에 도달하면 반대로 방향을 바꾸고 속력을 유지한 채로 이동합니다. 방향을 바꿀 때는 시간이 걸리지 않습니다.

# 모든 곰팡이가 이동을 끝낸 후에 한 칸에 곰팡이가 두마리 이상일 때는 크기가 큰 곰팡이가 다른 곰팡이를 모두 잡아먹습니다.

# 이 모든 과정은 1초가 걸리며 이후 승용이는 오른쪽 열로 이동해서 위의 과정을 반복합니다.

# 예를 들어 위의 상태에서 채취를 하고 난 뒤의 상태는 아래와 같이 변하게 됩니다.



# 이후에 곰팡이가 본인의 속도대로 이동하면 아래와 같은 상태로 변하게 됩니다.



# 끝나고 난 뒤 승용이는 열을 오른쪽으로 이동합니다.







# 이동 후에 5번째 행, 3번째 열에서 두 곰팡이가 부딪히게 됩니다. 이때 크기가 5인 곰팡이가 크기가 더 크기 때문에 나머지 곰팡이를 모두 잡아먹습니다. 그리고 나서 아래와 같이 바뀌게 됩니다.



# 승용이가 해당 격자판에 있는 모든 열을 검사했을 때, 채취한 곰팡이 크기의 총합을 구하는 프로그램을 구해보세요.

# 입력 형식
# 첫번째 줄에 격자판의 크기 n, m과 곰팡이의 수 k가 공백을 사이에 두고 주어집니다.

# 두번째 줄부터 k+1번째 줄까지 곰팡이의 정보 x, y, s, d, b가 주어집니다. x, y는 곰팡이의 위치를 의미하며, s는 1초동안 곰팡이가 움직이는 거리, d는 이동 방향, b는 곰팡이의 크기를 의미합니다. d는 1~4까지의 정수로 주어지며 1인 경우는 위, 2인 경우는 아래, 3인 경우는 오른쪽, 4인 경우는 왼쪽을 의미합니다. x와 y는 해당 격자판의 몇번째 행인지, 몇번째 열인지를 표시합니다. 즉 x는 위에서부터 아래까지 1번부터 차례로 번호를 매긴 것이고, y는 왼쪽에서부터 오른쪽까지 1번부터 차례로 번호를 매긴 것입니다.

# 2 ≤ n, m ≤ 100

# 0 ≤ k ≤ n*m

# 1 ≤ x ≤ n, 1 ≤ y ≤ m, 0 ≤ s ≤ 1000, 1 ≤ d ≤ 4, 1 ≤ b ≤ 10000

# 초기에 한 칸에 둘 이상의 곰팡이가 주어지는 경우는 없다고 가정해도 좋습니다.

# 출력 형식
# 인턴이 채취한 곰팡이 크기의 총 합을 출력하세요.

# 입출력 예제
# 예제1
# 입력:

# 5 6 5
# 2 1 5 3 3
# 2 5 5 2 2
# 3 2 0 3 1
# 5 1 1 4 5
# 5 3 4 1 4
# 출력:

# 11
# 예제2
# 입력:

# 100 7 7
# 3 2 2 3 9
# 3 3 1 3 3
# 3 5 1 4 7
# 3 6 2 4 6
# 2 4 1 2 8
# 1 4 2 2 4
# 4 4 1 1 5
# 출력:

# 0
# 제한
# 시간 제한: 1000ms
# 메모리 제한: 80MB
import copy
n, m, k=map(int, input().split())
grid=[[[] for _ in range(m)] for _ in range(n)]
for _ in range(k):
    vy, vx, vs, vd, vb=map(int, input().split())
    grid[vy-1][vx-1].append([vs, vd-1, vb])
dy, dx=[-1, 1, 0, 0], [0, 0, 1, -1]
answer=0
def move():
    global grid
    tmp=[[[] for _ in range(m)] for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if grid[i][j]:
                ny, nx, d=i, j, grid[i][j][0][1]
                for l in range(grid[i][j][0][0]):
                    ny+=dy[d]
                    nx+=dx[d]
                    if not (0<=ny<n and 0<=nx<m):
                        ny-=dy[d]
                        nx-=dx[d]
                        if d%2==0:
                            d+=1
                        else:
                            d-=1
                        ny+=dy[d]
                        nx+=dx[d]
                tmp[ny][nx].append([grid[i][j][0][0], d, grid[i][j][0][2]])
    for i in range(n):
        for j in range(m):
            if tmp[i][j]:
                if len(tmp[i][j])>=2:
                    tmp[i][j]=sorted(tmp[i][j], key=lambda x:x[2], reverse=True)[:1]
    grid=copy.deepcopy(tmp)
def monitoring(cur):
    global answer
    for i in range(n):
        if grid[i][cur]:
            answer+=grid[i][cur][0][2]
            grid[i][cur]=[]
            break
for i in range(m):
    monitoring(i)
    move()
print(answer)
