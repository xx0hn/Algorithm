# 숫자가 더 큰 인접한 곳으로 이동
# 1 ~ 100 사이의 숫자로 이루어진 n * n 크기의 격자판 정보가 주어집니다. 이때 특정 위치에서 시작하여, 상하좌우로 인접한 곳에 있는 숫자들 중 현재 위치에 있는 숫자보다 더 큰 위치로 끊임없이 이동합니다. 만약 그러한 위치가 여러개 있는 경우, 상하좌우 방향 순서대로 우선순위를 매겨 가능한 곳 중 우선순위가 더 높은 곳으로 이동합니다. 격자를 벗어나서는 안되며, 더 이상 움직일 수 없을 때까지 반복합니다.

# 위의 규칙에 따라 방문하게 되는 위치에 적힌 숫자를 순서대로 출력하는 프로그램을 작성해보세요.

# 예를 들어, 다음 그림의 경우를 살펴봅시다.



# 상하좌우 인접한 숫자들 중 5보다 큰 숫자는 8과 10 2개가 있지만, 아래 방향이 우선순위가 더 높으므로 숫자 8로 이동하게 됩니다.



# 8 위치에서는 오른쪽 방향으로만 이동이 가능하므로 숫자 11이 적혀있는 위치로 이동하게 됩니다.



# 이때는 11보다 큰 숫자가 인접한 곳에 없으므로 이동을 멈추게 됩니다.

# 입력 형식
# 첫 번째 줄에는 격자의 크기를 나타내는 n과 시작 위치를 나타내는 r, c 값이 각각 공백을 사이에 두고 주어집니다. r, c는 r행 c열에서 시작함을 의미합니다. (1 ≤ r, c ≤ n)

# 두 번째 줄 부터는 n개의 줄에 걸쳐 각 행에 해당하는 n개의 숫자가 공백을 사이에 두고 주어집니다.

# 1 ≤ n ≤ 100
# 출력 형식
# 첫 번째 줄에 시작 위치로부터 움직임이 종료될때 까지 방문한 격자에 적혀있는 숫자들을 공백을 사이에 두고 출력합니다.

# 입출력 예제
# 예제1
# 입력:

# 4 2 2
# 1 2 2 3
# 3 5 10 15
# 3 8 11 2
# 4 5 4 4
# 출력:

# 5 8 11
# 예제2
# 입력:

# 4 1 1
# 1 2 2 3
# 3 5 10 15
# 3 8 11 2
# 4 5 4 4
# 출력:

# 1 3 5 8 11
# 제한
# 시간 제한: 1000ms
# 메모리 제한: 80MB
n, r, c=map(int, input().split())
grid=[list(map(int, input().split())) for _ in range(n)]
dy, dx=[-1, 1, 0, 0], [0, 0, -1, 1]
def move(y, x, path):
    for i in range(4):
        ny, nx=y+dy[i], x+dx[i]
        if 0<=ny<n and 0<=nx<n and grid[ny][nx]>grid[y][x]:
            return move(ny, nx, path+[grid[ny][nx]])
    return path
print(*move(r-1, c-1, [grid[r-1][c-1]]))
