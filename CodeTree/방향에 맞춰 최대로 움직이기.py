# 방향에 맞춰 최대로 움직이기
# n * n격자에 각 칸마다 1에서 n * n 사이의 숫자와 여덟 방향 중 한 방향이 주어집니다. 숫자는 중복없이 단 한 번씩만 주어지며, 방향은 아래 그림에서 노란 칸을 중심으로 회색 칸들을 향하는 여덟 방향 중 하나입니다.



# 이때 특정 위치에서 시작하여 현재 위치에 적혀있는 방향에 있는 숫자들 중 현재 숫자보다 더 큰 숫자가 적혀있는 곳으로 이동하는 것을 최대한 많이 반복해보려고 합니다.

# 아래 그림을 살펴봅시다. 이 경우는 n = 3이고, 시작 위치가 3행 3열인 예입니다.



# 숫자 5에서는 5보다 숫자가 크면서 해당 방향에 있는 숫자 6, 7에 모두 갈 수 있습니다.

# 숫자 6으로 이동하게 될 경우에는 더 이상 조건을 만족하며 움직일 수 없게 됩니다.

# 하지만 숫자 7로 이동하게 된 경우, 조건을 만족하며 숫자 9로 이동이 가능하기 때문에 숫자 5에서 시작하여 총 2번 이동이 가능하게 됩니다.

# n * n 격자의 초기 상태가 주어졌을 때, 시작 위치로부터 조건을 만족하며 최대 몇 번 이동할 수 있는지를 구하는 프로그램을 작성해보세요.

# 입력 형식
# 첫 번째 줄에는 격자의 크기를 나타내는 n이 주어집니다.

# 그 다음 줄 부터는 n개의 줄에 걸쳐 해당 행의 각 칸에 적혀있는 n개의 숫자가 순서대로 공백을 사이에 두고 주어집니다.

# 그 다음 줄 부터는 n개의 줄에 걸쳐 해당 행의 각 칸에 적혀있는 방향을 나타내는 숫자가 순서대로 공백을 사이에 두고 주어집니다. 이 숫자는 1부터 8 사이의 숫자이며, 순서대로 ↑, ↗, →, ↘, ↓, ↙, ←, ↖ 방향을 의미합니다.

# 마지막 줄에는 시작 위치를 나타내는 (r, c) 값이 공백을 사이에 두고 주어집니다. 이는 r행 c열에서 시작함을 의미합니다. (1 ≤ r ≤ n, 1 ≤ c ≤ n)

# 1 ≤ n ≤ 4
# 출력 형식
# 조건을 만족하며 이동할 수 있는 최대 횟수를 출력합니다.

# 입출력 예제
# 예제1
# 입력:

# 3
# 7 1 4
# 2 6 3
# 9 8 5
# 5 3 1
# 6 3 7
# 2 4 8
# 3 3
# 출력:

# 2
# 예제2
# 입력:

# 3
# 2 8 9
# 6 4 5
# 3 7 1
# 5 3 1
# 6 3 7
# 2 4 8
# 3 3
# 출력:

# 5
# 제한
# 시간 제한: 1000ms
# 메모리 제한: 80MB
n=int(input())
grid=[list(map(int, input().split())) for _ in range(n)]
ds=[list(map(int, input().split())) for _ in range(n)]
c_y, c_x=map(int, input().split())
c_y, c_x=c_y-1, c_x-1
dy, dx=[-1, -1, 0, 1, 1, 1, 0, -1], [0, 1, 1, 1, 0, -1, -1, -1]
answer=0
def move(y, x, cnt):
    global answer
    for i in range(1, n):
        ny, nx=y+i*dy[ds[y][x]-1], x+i*dx[ds[y][x]-1]
        if 0<=ny<n and 0<=nx<n and grid[y][x]<grid[ny][nx]:
            answer=max(answer, cnt+1)
            move(ny, nx, cnt+1)
        else:
            continue
move(c_y, c_x, 0)
print(answer)
