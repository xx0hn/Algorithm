# 기울어진 직사각형의 회전
# 1~100 사이의 숫자로만 이루어져 있는 n * n 크기의 격자 정보가 주어집니다.



# 이때, 이 격자 내에 있는 임의의 기울어진 직사각형을 잡아 회전시키려고 합니다.

# 기울어진 직사각형이란, 격자내에 있는 한 지점으로부터 체스의 비숍처럼 대각선으로 움직이며 반시계 순회를 했을 때 지나왔던 지점들의 집합을 일컫습니다. 이 때 반드시 아래에서 시작해서 1, 2, 3, 4번 방향순으로 순회해야하며 각 방향으로 최소 1번은 움직여야 합니다. 또한, 이동하는 도중 격자 밖으로 넘어가서는 안됩니다.



# 예를 들어 위의 규칙에 따라 다음과 같이 기울어진 직사각형을 잡아볼 수 있습니다.



# 위의 기울어진 직사각형의 경우 4행 2열 위치에서 시작하여 순서대로 1번 방향으로 2칸, 2번 방향으로 1칸, 3번 방향으로 2칸, 4번 방향으로 1칸 이동했으므로 이는 편의상 4, 2, 2, 1, 2, 1로 나타낼 수 있습니다. 만약 이 직사각형의 순회경로상에 있는 색칠된 숫자들에 대해서만 반시계 방향으로 한 칸씩 숫자들을 움직이게 된다면, 다음과 같이 숫자들이 바뀌게 됩니다.



# 초기 격자의 정보와 특정 기울어진 사각형에 대해서 반시계 혹은 시계 방향으로 회전해야 하는 정보가 주어졌을 때, 회전 이후의 결과를 출력하는 프로그램을 작성해보세요.

# 입력 형식
# 첫 번째 줄에는 격자의 크기를 나타내는 n이 주어집니다.

# 두 번째 줄부터는 n개의 줄에 걸쳐 격자에 대한 정보가 주어집니다. 각 줄에는 각각의 행에 대한 정보가 주어지며, 이 정보는 1에서 100사이의 숫자로 각각 공백을 사이에 두고 주어집니다.

# 그 다음 줄에는 기울어진 직사각형의 정보와 회전 방향을 나타내는 (r, c, m1, m2, m3, m4, dir)값이 각각 공백을 사이에 두고 주어집니다. 이는 기울어진 직사각형이 r행, c열에서 시작하여 1번, 2번, 3번, 4번 방향으로 각각 m1, m2, m3, m4만큼 순서대로 이동했을 때 그려지는 직사각형임을 의미하며, dir이 0인 경우에는 반시계 방향으로 1칸씩 회전해야 함을, dir이 1인 경우에는 시계 방향으로 1칸씩 회전해야 함을 의미합니다. 올바르지 않은 기울어진 직사각형의 정보가 주어지는 경우는 없다고 가정해도 좋습니다. (1 ≤ r, c ≤ n)

# 3 ≤ n ≤ 100
# 출력 형식
# 회전 이후 격자의 상태를 출력해주세요. n개의 줄에 걸쳐 각 행에 적혀있는 n개의 숫자들을 공백을 사이에 두고 출력합니다.

# 입출력 예제
# 예제1
# 입력:

# 5
# 1 2 2 2 2
# 1 3 4 4 4
# 1 2 3 3 3
# 1 2 3 3 3
# 1 2 3 3 3
# 4 2 2 1 2 1 0
# 출력:

# 1 2 4 2 2
# 1 2 4 3 4
# 3 2 2 3 3
# 1 1 3 3 3
# 1 2 3 3 3
# 예제2
# 입력:

# 5
# 1 2 2 2 2
# 1 3 4 4 4
# 1 2 3 3 3
# 1 2 3 3 3
# 1 2 3 3 3
# 4 2 2 1 2 1 1
# 출력:

# 1 2 3 2 2
# 1 1 4 2 4
# 2 2 4 3 3
# 1 3 3 3 3
# 1 2 3 3 3
# 제한
# 시간 제한: 1000ms
# 메모리 제한: 80MB
import copy
n=int(input())
grid=[list(map(int, input().split())) for _ in range(n)]
r, c, m1, m2, m3, m4, dr=map(int, input().split())
def cycling(r, c, k, l, dr):
    result=copy.deepcopy(grid)
    if dr==0:
        dr, dc=[-1, -1, 1, 1], [1, -1, -1, 1]
        move=[k, l, k, l]
    else:
        dr, dc=[-1, -1, 1, 1], [-1, 1, 1, -1]
        move=[l, k, l ,k]
    for i in range(4):
        for j in range(move[i]):
            nr, nc=r+dr[i], c+dc[i]
            result[nr][nc]=grid[r][c]
            r, c=nr, nc
    return result
grid=copy.deepcopy(cycling(r-1, c-1, m1, m2, dr))
for i in range(n):
    print(*grid[i])
