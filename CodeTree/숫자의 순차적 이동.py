# 숫자의 순차적 이동
# 1 ~ n * n 사이의 숫자들이 정확히 한번씩만 등장하는 n * n 크기의 격자판 정보가 주어집니다. 이때 m번의 턴에 걸쳐 숫자들을 이동하려고 합니다. 한 번의 턴에는 숫자 1이 적힌 위치에서부터 숫자 n * n이 적힌 위치까지 순서대로 하나씩 보면서 특정 조건에 맞춰 다들 한번씩 움직입니다. 이 조건이란, 각 위치에서 여덟방향으로 인접한 칸들 중 가장 큰 숫자와 가운데 칸의 숫자를 교환하는 것입니다. 여덟방향으로 인접한 위치란, 예를 들어 아래 그림에서 노란색 위치를 기준으로 회색 위치를 의미합니다.



# 아래 그림을 살펴봅시다.



# 첫 번째 턴에 대해 다음 과정을 밟게 됩니다.

# 먼저 숫자 1부터 시작합니다. 이 경우 여덟방향으로 인접한 숫자들 중 가장 큰 값인 13과 위치를 바꾸게 됩니다.



# 그 다음 숫자 2를 움직입니다. 이 경우 여덟방향으로 인접한 숫자들 중 가장 큰 값인 14와 위치를 바꾸게 됩니다.



# 이 과정을 순차적으로 숫자 16까지 각각 한번씩 반복하게 되면, 결과는 다음과 같이 나오게 되며 이 과정을 거친 것을 한 번의 턴 이라고 부릅니다.



# m번의 턴을 거친 이후 격자판의 상태를 출력하는 프로그램을 작성해보세요.
# 입력 형식
# 첫 번째 줄에는 격자의 크기를 나타내는 n과 턴의 수를 나타내는 m 값이 공백을 사이에 두고 주어집니다.

# 두 번째 줄 부터는 n개의 줄에 걸쳐 각 행에 해당하는 n개의 숫자가 공백을 사이에 두고 주어집니다. 1부터 n * n사이의 숫자가 정확히 한번씩만 나온다고 가정해도 좋습니다.

# 2 ≤ n ≤ 20

# 1 ≤ m ≤ 100

# 출력 형식
# m번의 턴을 거친 이후 격자판의 상태를 출력합니다.

# n개의 줄에 걸쳐 각 행에 해당하는 n개의 숫자를 공백을 사이에 두고 출력합니다.

# 입출력 예제
# 예제1
# 입력:

# 4 1
# 15 13 1 11
# 4 8 3 5
# 2 12 16 7
# 14 6 9 10
# 출력:

# 4 1 13 11
# 8 12 5 7
# 6 15 3 9
# 2 14 16 10
# 예제2
# 입력:

# 4 2
# 15 13 1 11
# 4 8 3 5
# 2 12 16 7
# 14 6 9 10
# 출력:

# 13 4 1 9
# 12 15 7 11
# 14 2 5 16
# 6 8 3 10
# 제한
# 시간 제한: 1000ms
# 메모리 제한: 80MB
n, m=map(int, input().split())
grid=[list(map(int, input().split())) for _ in range(n)]
def move(y, x):
    dy, dx=[-1, -1, 0, 1, 1, 1, 0, -1], [0, 1, 1, 1, 0, -1, -1 , -1]
    mx, idx=-1, [0, 0]
    for i in range(8):
        ny, nx=y+dy[i], x+dx[i]
        if 0<=ny<n and 0<=nx<n and grid[ny][nx]>mx:
            mx=grid[ny][nx]
            idx=[ny, nx]
    grid[y][x], grid[idx[0]][idx[1]]=grid[idx[0]][idx[1]], grid[y][x]
for t in range(m):
    for num in range(1, n*n+1):
        chk=False
        for i in range(n):
            for j in range(n):
                if grid[i][j]==num:
                    move(i, j)
                    chk=True
                    break
            if chk:
                break
for i in range(n):
    print(*grid[i])
