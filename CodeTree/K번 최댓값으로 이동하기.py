# K번 최댓값으로 이동하기
# n*n 크기의 격자에 1에 100 사이의 숫자가 각 칸에 하나씩 주어져 있습니다. 이때 특정 위치에서 시작하여 아래 조건을 만족하는 숫자의 위치를 찾아 상하좌우로만 이동합니다. 이렇게 이동하는 것을 k번 반복한 이후의 위치를 구하는 프로그램을 작성해보세요. 만약 아직 k번을 반복하지 못했지만, 더 이상 새로 이동할 위치가 없다면 움직이는 것을 종료합니다.

# 한번 이동하기 위한 조건은 다음과 같습니다.

# 시작 위치에 적혀있는 숫자를 x라고 했을 때, 시작 위치에서 출발하여 인접한 칸들 중 적혀있는 숫자가 x보다 작은 곳으로는 전부 이동이 가능합니다.

# 다음 그림을 예로 들어보겠습니다. 시작 위치가 4행 3열인 숫자 10이라고 했을 때, 10보다 큰 11을 제외한 인접한 모든 숫자들로 이동이 가능합니다.



# 1-1. 하지만 만약에 아래 그림처럼 시작 위치의 상하좌우가 시작 숫자(= 10)보다 큰 숫자들(= 11)로 둘러쌓여져 있으면 이동이 불가합니다.




# 1번 조건을 만족하며 도달할 수 있는 칸들에 적혀있는 숫자 중 최댓값으로 이동합니다.



# 위 그림과 같이 시작 위치에 적혀있는 숫자 10에서 출발하여 인접한 칸들 중 10보다 작지만 그 중 최댓값인 9로 이동을 고려합니다.

# 2번 조건을 만족하는 숫자가 여러개 일경우, 행 번호가 가장 작은 곳으로 이동합니다. 아래 그림과 같이 2행에 있는 최댓값(= 9)이 두개 있습니다.




# 2번 조건을 만족하고, 행 번호도 같은 숫자가 여러개 일경우, 열 번호가 가장 작은 곳으로 이동합니다.



# 결론적으로 4행 3열에서 시작하여 인접한 곳으로 숫자 10보다 작은 곳들로 이동했을 때 갈 수 있는 칸들 중 최대 숫자는 9이고, 그 중 우선순위가 가장 높은 곳은 2행 2열입니다. 따라서 2행 2열 위치로 이동하게 됩니다.


# 2행 2열 위치를 시작으로 한번 더 움직임을 반복해보면, 2행 2열에서 시작하여 인접한 곳으로 숫자 9보다 작은 곳들로 이동했을 때 갈 수 있는 칸들 중 최대 숫자는 6이고, 그 중 우선순위가 가장 높은 곳은 2행 3열입니다. 따라서 2행 3열 위치로 이동하게 됩니다.




# 2행 3열 위치를 시작으로 한번 더 움직임을 반복해보면, 2행 3열에서 시작하여 인접한 곳으로 숫자 6보다 작은 곳들로 이동했을 때 갈 수 있는 칸들 중 최대 숫자는 4이고, 4는 2행 1열입니다. 따라서 2행 1열 위치로 이동하게 됩니다.




# 이렇게 이동하는 것을 k번 반복한 후의 위치를 구하는 프로그램을 작성해보세요. 아직 k번을 반복하지 못했더라도, 더 이상 새로 이동할 위치가 없다면 움직이는 것을 종료해야함에 유의합니다.

# 입력 형식
# 첫 번째 줄에는 격자의 크기를 나타내는 n과 반복할 횟수를 나타내는 k가 공백을 사이에 두고 주어집니다.

# 두 번째 줄 부터는 n개의 줄에 걸쳐 각 행에 해당하는 n개의 숫자가 순서대로 공백을 사이에 두고 주어집니다.

# 마지막 줄에는 초기 시작 위치 (r, c)가 공백을 사이에 두고 주어집니다. (r, c)는 r행 c열에서 시작함을 의미합니다. (1 ≤ r ≤ n, 1 ≤ c ≤ n)

# 1 ≤ n, k ≤ 100
# 출력 형식
# 이동하는 것을 k번 반복한 이후의 위치 (r, c)를 출력합니다. (r, c)는 최종 위치가 r행 c열임을 의미합니다.

# 입출력 예제
# 예제1
# 입력:

# 4 2
# 1 3 2 11
# 4 9 6 9
# 2 6 9 8
# 1 9 10 7
# 4 3
# 출력:

# 2 3
# 예제2
# 입력:

# 4 4
# 1 3 2 11
# 4 9 6 9
# 2 6 9 8
# 1 9 10 7
# 4 3
# 출력:

# 1 2
# 제한
# 시간 제한: 1000ms
# 메모리 제한: 80MB
from collections import deque
n, k=map(int, input().split())
grid=[list(map(int, input().split())) for _ in range(n)]
sy, sx=map(int, input().split())
sy, sx=sy-1, sx-1
dy, dx=[-1, 0, 0, 1], [0, -1, 1, 0]
visited = [[False for _ in range(n)] for _ in range(n)]
def bfs(cur_y, cur_x):
    q=deque()
    q.append((cur_y, cur_x))
    visited[cur_y][cur_x]=True
    standard=grid[cur_y][cur_x]
    while q:
        y, x=q.popleft()
        for i in range(4):
            ny, nx=y+dy[i], x+dx[i]
            if 0<=ny<n and 0<=nx<n and not visited[ny][nx] and grid[ny][nx]<standard:
                visited[ny][nx]=True
                q.append((ny, nx))
def find_best(cur_y, cur_x):
    result=-1
    ry, rx=-1, -1
    for i in range(n):
        for j in range(n):
            if not visited[i][j] or (i, j)==(cur_y, cur_x):
                continue
            else:
                if grid[i][j]>result:
                    result=grid[i][j]
                    ry, rx=i, j
    if (ry, rx)==(-1, -1):
        return -1, -1
    return ry, rx
for _ in range(k):
    for i in range(n):
        for j in range(n):
            visited[i][j]=False
    bfs(sy, sx)
    ans_y, ans_x=find_best(sy, sx)
    if (ans_y, ans_x)==(-1, -1):
        break
    else:
        sy, sx=ans_y, ans_x
print(sy+1, sx+1)
