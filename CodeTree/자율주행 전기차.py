# 자율주행 전기차
# 실력체크
# 정답률 31% · 제출 215회 · 예상 소요 시간 169분

# 추천해요
# 아쉬워요
# 자율주행 전기차를 이용해서 택시 업무를 진행하고자 합니다. 하지만 현재 사용하는 자율주행 전기차는 베타테스트 버전이기 때문에 배터리 양이 모두 소진되는 경우 더이상 움직일 수 없습니다. 테스트를 위해 n * n 격자의 도로 위에 차가 지나갈 수 없는 벽의 위치와 m명의 승객의 위치가 주어질 때 주어진 배터리 용량으로 승객을 모두 태워줄 수 있는지를 알아보고자 합니다.

# 자율주행 전기차는 승객을 태우러 출발지에 이동할 때에나 태우고 목적지로 이동할 때 항상 최단 거리로 이동합니다. 자율주행 전기차는 한 칸을 이동할 때 1만큼의 배터리를 소요하고, 승객을 목적지로 무사히 태워주면 그 승객을 태워서 이동하며 소모한 배터리 양의 두 배만큼을 충전한 뒤 다시 이동합니다. 이동하는 도중에 배터리가 모두 소모되면 그 즉시 종료되며, 만일 승객을 목적지로 이동시킨 동시에 배터리가 모두 소모되는 경우에는 승객을 태우며 소모한 배터리의 두 배만큼 충전되어 다시 운행을 시작할 수 있습니다. 마지막 승객을 태워주고 운행을 종료하는 순간에도 충전은 이뤄집니다.

# 승객이 여러명일 경우 현재 위치에서 최단 거리가 가장 짧은 승객을 먼저 태웁니다. 만약 그런 승객이 여러 명일 경우에는 가장 위에 있는 승객을, 그런 승객이 여러 명일 때는 가장 왼쪽에 있는 승객을 고릅니다.

# 예를 들어 다음과 같이 도로 상태가 주어질 때, 아래와 같이 진행되는 것을 알 수 있습니다.















# 도로의 상태가 주어질 때 모든 승객을 성공적으로 데려다 줄 수 있는지 알아내고, 데려다줄 수 있는 경우 최종적으로 남는 배터리의 양을 출력하는 프로그램을 작성하세요.

# 입력 형식
# 첫번째 줄에는 격자의 크기 n, 승객의 수 m, 초기 배터리 충전량 c가 공백을 사이에 두고 주어집니다.

# 두번째 줄부터 n+1번째 줄까지는 도로의 정보가 주어집니다. 0은 도로를, 1은 벽을 나타냅니다.

# n+2번째 줄에는 자율주행 전기차의 초기 위치 정보 x, y가 주어집니다.

# n+3번째 줄부터 m개의 줄은 각 승객의 출발지의 위치 정보 x_s, y_s, 도착지의 위치 정보 x_e, y_e가 주어집니다.

# 위치 정보 x, y는 각각 몇 번째 행인지 몇 번째 열인지를 알려줍니다. 즉 1부터 n 사이의 자연수로 주어집니다.

# 2 ≤ n ≤ 20

# 1 ≤ m ≤ n^{2} 
# 2
 

# 1 ≤ c ≤ 500,000

# 모든 승객의 출발지와 목적지는 빈칸으로 가정해도 좋습니다.

# 각 승객의 출발지와 목적지는 모두 다르다고 가정해도 좋습니다.

# 단 한 승객의 출발지와 다른 승객의 목적지는 같을 수 있습니다.

# 서로 다른 승객의 출발지가 동일한 경우는 없다고 가정해도 좋습니다.

# 출력 형식
# 모든 손님을 이동시키고 연료를 충전한 뒤에 남은 연료의 양을 출력하세요. 만약 모든 손님을 이동할 수 없다면 -1 출력하세요.

# 입출력 예제
# 예제1
# 입력:

# 5 3 10
# 0 0 0 0 0
# 1 0 0 1 0
# 0 0 0 0 0
# 0 1 0 0 0
# 0 1 0 0 0
# 5 1
# 2 3 3 4
# 5 3 5 4
# 1 5 1 1
# 출력:

# 3
# 예제2
# 입력:

# 5 5 4
# 0 0 0 0 0
# 0 0 0 0 0
# 0 0 0 0 0
# 0 0 0 0 0
# 0 0 0 0 0
# 3 3
# 2 2 4 2
# 4 2 4 4
# 4 4 2 4
# 2 4 2 2
# 2 5 3 3
# 출력:

# 10
# 예제3
# 입력:

# 6 1 1
# 0 0 0 0 0 0
# 0 0 0 0 0 0
# 0 0 0 0 0 0
# 0 0 0 0 0 0
# 0 0 0 0 0 0
# 0 0 0 0 0 0
# 3 4
# 3 4 2 5
# 출력:

# -1
# 제한
# 시간 제한: 1000ms
# 메모리 제한: 80MB
import heapq
n, m, c=map(int, input().split())
grid=[list(map(int, input().split())) for _ in range(n)]
cy, cx=map(int, input().split())
cur=[cy-1, cx-1]
dy, dx=[0, 1, 0, -1], [1, 0, -1, 0]
ps=[]
for _ in range(m):
    y1, x1, y2, x2=map(int, input().split())
    ps.append([y1-1, x1-1, y2-1, x2-1])
def dijkstra(sy, sx):
    heap=[]
    heapq.heappush(heap, (0, sy, sx))
    dist=[[1e9 for _ in range(n)] for _ in range(n)]
    dist[sy][sx]=0
    while heap:
        d, y, x=heapq.heappop(heap)
        if d>dist[y][x]:
            continue
        for i in range(4):
            ny, nx=y+dy[i], x+dx[i]
            if 0<=ny<n and 0<=nx<n and grid[ny][nx]==0:
                if dist[ny][nx]>dist[y][x]+1:
                    dist[ny][nx]=dist[y][x]+1
                    heapq.heappush(heap, (dist[y][x]+1, ny, nx))
    return dist
ps.sort(key=lambda x:(x[0], x[1]))
while ps:
    dists=dijkstra(cur[0], cur[1])
    p=1e9
    idx=[]
    num=0
    for i in range(len(ps)):
        y1, x1, _, _=ps[i]
        if p>dists[y1][x1]:
            p=dists[y1][x1]
            idx=[y1, x1]
            num=i
    cur=idx
    c-=p
    if c<0:
        print(-1)
        quit()
    to_dest=dijkstra(cur[0], cur[1])
    cost=to_dest[ps[num][2]][ps[num][3]]
    c-=cost
    if c<0:
        print(-1)
        quit()
    c+=cost*2
    cur=[ps[num][2], ps[num][3]]
    ps.pop(num)
print(c)
