# 1차원 바람
# 0과 9 사이의 숫자로만 이루어진 N*M 행렬 모양의 건물에 총 Q번의 바람이 붑니다.

# 바람은 특정 행의 모든 원소들을 왼쪽 혹은 오른쪽으로 전부 한 칸씩 밀어 shift 하는 효과를 가져옵니다.



# 이 바람에 영향을 받아 특정 행의 숫자들이 한 칸씩 밀리게 되면, 위 아래로도 영향을 미치기 시작합니다. 밀리기 시작한 행을 기준으로 위 아래 방향으로 순차적으로 전파가 되며 도중에 전파 방향이 바뀌는 경우는 없습니다.



# 전파가 이어질 조건은 현재 행과 나아가려는 행을 비교했을 때, 단 하나라도 같은 열에 같은 숫자가 적혀있는 경우라면 전파를 이어나갑니다. 같은 숫자가 하나도 존재하지 않거나 끝에 다다랐다면 전파를 종료합니다. 전파가 진행되는 경우 나아가려는 행의 숫자들을 한 칸씩 밀게되며, 현재 행이 밀렸던 방향과 반대 방향으로 작용합니다.

# 예를 들어 위의 예에서 우측 방향으로 바람이 불어와 3번째 행이 오른쪽으로 한 칸 밀린 이후에는 2행, 4행 방향으로 전파를 시도합니다. 2번째 행과 4번째 행 모두 3번째 행과 같은 열에서 일치하는 숫자가 하나 이상 존재하므로 전파를 진행합니다. 이때, 3행은 우측 방향으로 밀렸던 행이므로 2행, 4행은 전파의 영향을 받아 전부 반대 방향인 좌측 방향으로 한 칸씩 밀리게 됩니다.



# 전파는 계속 진행됩니다. 2행과 4행은 진행했던 방향으로 그다음 전파를 시도합니다.

# 2행은 1행과의 비교에서 같은 열에 일치하는 숫자가 존재하지 않으므로 위로 진행하는 전파를 중단합니다. 하지만 4행의 경우 5행과 일치하는 숫자가 하나 존재하므로 전파를 진행합니다. 이때, 4행은 좌측으로 밀렸던 행이므로 5행은 전파의 영향을 받아 반대 방향인 우측 방향으로 한 칸씩 밀리게 됩니다.



# 위로 진행하던 전파는 막혔으므로 더 이상 진행되지 않습니다. 아래로는 여전히 전파를 시도하게 되고, 5행과 6행은 일치하는 숫자가 있기 때문에 전파를 진행합니다. 이때 5행은 좌측으로 밀렸던 행이므로 6행은 전파의 영향을 받아 반대 방향인 좌측 방향으로 한 칸씩 밀리게 됩니다.



# 이제 아래로 진행하던 전파는 끝에 다다랐기 때문에 진행을 중단합니다.

# 위에서 든 예시에서 한 바람이 불었을 때 건물에 영향을 미치는 과정을 요약해보면 다음과 같습니다.



# 한 바람이 분 이후 모든 전파가 완료 되었을 때 그 다음 바람이 불어 온다고 할 때, 총 Q개의 바람을 거친 이후 건물의 상태를 출력하는 프로그램을 작성해보세요

# 입력 형식
# 첫째 줄에는 행렬의 크기를 나타내는 N과 M 그리고 총 바람이 불어온 횟수를 의미하는 Q가 공백을 사이에 두고 주어집니다.

# 두 번째 줄 부터 N개의 줄에 걸쳐 한 줄에 M개 씩 건물의 상태를 나타내는 0부터 9 사이의 숫자가 공백을 사이에 두고 주어집니다.

# 그 다음 줄 부터는 Q개의 줄에 걸쳐 불어오는 바람에 대한 정보 (r, d)가 공백을 사이에 두고 주어집니다. r은 바람에 영향을 받는 행 번호를 의미하며 d는 바람이 불어오는 방향을 의미합니다. d는 ‘L' 또는 ‘R’의 값을 가지며, ‘L’은 바람이 왼쪽에서 불어온다는 것을 'R’은 바람이 오른쪽에서 불어온다는 것을 의미합니다. (1 ≤ r ≤ N)

# 1 ≤ N ≤ 100

# 1 ≤ M ≤ 100

# 0 ≤ Q ≤ 100

# 출력 형식
# Q개의 바람을 거친 이후 건물의 상태를 N개의 줄에 걸쳐 출력합니다. 각 줄마다 각각의 행에 해당하는 M개의 값을 공백을 사이에 두고 출력합니다.

# 입출력 예제
# 예제1
# 입력:

# 6 5 1
# 1 5 6 7 3
# 5 3 2 5 4
# 6 4 5 2 5
# 2 6 1 0 5
# 5 1 2 1 6
# 4 2 5 2 8
# 3 L
# 출력:

# 1 5 6 7 3
# 3 2 5 4 5
# 5 6 4 5 2
# 6 1 0 5 2
# 6 5 1 2 1
# 2 5 2 8 4
# 예제2
# 입력:

# 3 3 2
# 1 2 3
# 3 2 1
# 3 3 3
# 3 L
# 1 L
# 출력:

# 2 3 1
# 1 3 2
# 3 3 3
# 제한
# 시간 제한: 1000ms
# 메모리 제한: 80MB
from collections import deque
n, m, q=map(int, input().split())
grid=[deque(list(map(int, input().split()))) for _ in range(n)]
wind=[list(map(str, input().split())) for _ in range(q)]
def chk(r1, r2):
    for i in range(m):
        if grid[r1][i]==grid[r2][i]:
            return True
    return False
def shift(idx, d):
    grid[idx].rotate(d)
def move(idx, d): 
    # idx: wind[0]-1, d=L: -> (1), R: <- (-1)
    shift(idx, d)
    d*=-1
    cur_d=d
    for i in range(idx, 0, -1):
        if chk(i, i-1):
            shift(i-1, cur_d)
            cur_d*=-1
        else:
            break
    cur_d=d
    for i in range(idx, n-1):
        if chk(i, i+1):
            shift(i+1, cur_d)
            cur_d*=-1
        else:
            break
for i in range(q):
    if wind[i][1]=='L':
        move(int(wind[i][0])-1, 1)
    else:
        move(int(wind[i][0])-1, -1)
for i in range(n):
    print(*grid[i])
