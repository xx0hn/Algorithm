# 벽이 있는 충돌 실험
# M개의 구슬이 N*N 격자 안에 놓여져 있고, 격자는 벽으로 둘러쌓여 있습니다.



# 각 구슬은 모두 1초에 한 칸씩 동일한 속도로 정해진 방향으로 움직이고 있습니다.



# 구슬이 벽에 부딪히면 움직이는 방향이 반대로 뒤집혀 동일한 속도로 움직이는 것을 반복합니다. 이때 역시 방향을 바꾸는 것까지 포함해 정확히 1초의 시간이 소요됩니다.



# 두 개 이상의 구슬이 충돌하게 되면 부딪힌 구슬 모두 사라지게 됩니다.


# 이 때 충돌은 두 구슬이 이동 후 같은 위치에 있는 경우에만 일어납니다.

# 예를 들어 다음과 같이 이동 중에 만나는 경우라면, 서로 충돌이 일어나지 않습니다.



# 각 구슬의 초기상태가 주어졌을 때, 아주 오랜시간이 흐른 후에도 여전히 격자 안에 남아있는 구슬의 개수를 출력하는 프로그램을 작성해보세요.

# 입력 형식
# 첫째 줄에는 총 테스트 케이스 수를 나타내는 T가 주어집니다.

# 그 다음 줄 부터는 T개의 테스트 케이스에 대한 정보가 주어집니다.

# 각 테스트 케이스 마다 주어지는 입력 형식은 다음과 같습니다.

# 특정 테스트 케이스의 첫 번째 줄에는 N과 M이 공백을 사이에 두고 주어집니다.

# 특정 테스트 케이스의 두 번째 줄 부터는 M개의 줄에 걸쳐 구슬의 정보 (x, y, d)가 공백을 사이에 두고 주어집니다. 각 구슬이 x행 y열에서 d방향으로 이동중이라는 의미이며 d는 위 아래 오른쪽 왼쪽을 의미하는 ‘U', ‘D’, ‘R’, 'L’ 4개의 문자 중 하나가 주어집니다. 처음부터 구슬이 겹쳐져 주어지는 경우는 없다고 가정해도 좋습니다. (1 ≤ x ≤ N, 1 ≤ y ≤ N)

# 1 ≤ T ≤ 100

# 1 ≤ N ≤ 50

# 0 ≤ M ≤ N*N

# 출력 형식
# 한 줄에 하나씩 총 T개의 줄에 걸쳐 해당 테스트 케이스에 해당하는 남아있는 구슬의 수를 출력합니다.

# 입출력 예제
# 예제1
# 입력:

# 1
# 4 5
# 1 2 L
# 2 3 U
# 3 1 R
# 3 4 D
# 4 2 U
# 출력:

# 1
# 예제2
# 입력:

# 3
# 2 2
# 1 1 L
# 2 2 R
# 2 2
# 1 1 D
# 2 2 R
# 2 2
# 1 1 L
# 1 2 R
# 출력:

# 2
# 0
# 2
# 제한
# 시간 제한: 1000ms
# 메모리 제한: 80MB
t=int(input())
mapping={'U': 0, 'R': 1, 'L': 2, 'D': 3}
dy, dx=[-1, 0, 0, 1], [0, 1, -1, 0]
def move(o):
    y, x, d=o
    ny, nx=y+dy[d], x+dx[d]
    if 0<=ny<n and 0<=nx<n:
        return (ny, nx, d)
    else:
        return (y, x, 3-d)
def moving():
    for i in range(len(o)):
        o[i]=move(o[i])
def rmv():
    global o
    for y, x, _ in o:
        cnt[y][x]+=1
    new_o=[]
    for y, x, d in o:
        if cnt[y][x]==1:
            new_o.append((y, x, d))
    for y, x, _ in o:
        cnt[y][x]-=1
    o=new_o
for _ in range(t):
    n, m=map(int, input().split())
    o=[]
    cnt=[[0 for _ in range(n)] for _ in range(n)]
    for _ in range(m):
        x, y, d=map(str, input().split())
        x, y=int(x)-1, int(y)-1
        o.append((x, y, mapping[d]))
    for _ in range(2*n):
        moving()
        rmv()
    print(len(o))
